# Feature 11: Implement Aspire Dashboard Integration

## Feature Description

This feature implements Docker-based management of the Aspire Dashboard for local observability. It ports the `/telemetry start|stop|status|url` commands from the Python `agent-base` project to TypeScript in `telemetry/aspire.ts`. The implementation provides functions to start/stop the Aspire Dashboard container, check container status, display the dashboard URL, and auto-enable telemetry in config when the dashboard starts.

This is the third and final deliverable of Phase 1b (Foundation - Observability) and completes the observability foundation by providing a local visualization endpoint for the traces generated by Features 9-10.

## User Story

As an agent framework developer
I want to manage a local telemetry dashboard via CLI commands
So that I can visualize OpenTelemetry traces and debug agent behavior without setting up external infrastructure

## Problem Statement

The agent framework now has OpenTelemetry setup (Feature 9) and GenAI semantic conventions (Feature 10), but lacks a convenient way to visualize traces locally. Without Aspire Dashboard integration:

1. Developers must manually run Docker commands to start the dashboard
2. There's no easy way to check if the dashboard is running
3. Telemetry must be manually enabled/disabled in config
4. Error messages for Docker issues are inconsistent
5. The dashboard URL is not easily discoverable

## Solution Statement

Implement `telemetry/aspire.ts` with:
1. `startAspireDashboard()` - Start the Aspire Dashboard Docker container
2. `stopAspireDashboard()` - Stop the running container
3. `getAspireStatus()` - Check container status and return dashboard URLs
4. `getAspireUrl()` - Return dashboard URL and telemetry status
5. Auto-enable/disable telemetry in config when starting/stopping
6. Clear error messages for Docker unavailability scenarios

## Related Documentation

### Requirements
- Feature defined in: `docs/plans/typescript-rewrite-features.md` (Feature 11, lines 75-81)
- Phase: 1b (Foundation - Observability)
- Dependencies: Feature 9 (OTel Setup) - COMPLETED, Feature 10 (GenAI Conventions) - COMPLETED

### Architecture Decisions
- ADR-0003: Bun Runtime (subprocess execution via Bun.spawn)
- Runtime Boundary Pattern: `src/runtime/subprocess.ts` abstracts Bun.spawn for testability with Jest

### Reference Documents
- `docs/architecture.md`: Telemetry Architecture section (lines 621-654)
- Python implementation: `../agent-base/src/agent/cli/commands.py` (lines 252-477)
- Aspire Dashboard: https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/dashboard/overview

## Codebase Analysis Findings

### Architecture Patterns

**Response Contract**: All functions return `TelemetryResponse<T>` with:
```typescript
// Success
{ success: true, result: T, message: string }

// Error
{ success: false, error: TelemetryErrorCode, message: string }
```

**Subprocess Execution**: Use runtime boundary for Docker commands:
```typescript
// Use runtime/subprocess.ts for Bun/Node compatibility
import { spawnProcess } from '../runtime/subprocess.js';

const result = await spawnProcess(['docker', ...args], {
  stdout: 'pipe',
  stderr: 'pipe',
});
// Returns: { exitCode, stdout, stderr }
```

**Config Integration**: Use `ConfigManager` for load/save with validation

**Error Handling**: Never throw - return error responses with typed error codes

### Existing Infrastructure

- **Telemetry Types**: `src/telemetry/types.ts` with `TelemetryErrorCode`, `TelemetryResponse`
- **Telemetry Setup**: `src/telemetry/setup.ts` with `isEndpointReachable()`
- **Config Manager**: `src/config/manager.ts` with `load()`, `save()`
- **Config Schema**: `src/config/schema.ts` with `TelemetryConfigSchema`

### Python Implementation Analysis

From `agent-base/src/agent/cli/commands.py`:

**Constants**:
- `CONTAINER_NAME = "aspire-dashboard"`
- `DASHBOARD_URL = "http://localhost:18888"`
- `OTLP_ENDPOINT = "http://localhost:4317"`

**Docker Commands**:
1. Check CLI: `docker --version` (5s timeout)
2. Check daemon: `docker info` (10s timeout)
3. Check running: `docker ps --filter name=<name> --format {{.Names}}`
4. Start container: `docker run --rm -d -p 18888:18888 -p 4317:18889 --name aspire-dashboard -e DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS=true mcr.microsoft.com/dotnet/aspire-dashboard:latest`
5. Stop container: `docker stop <name>`
6. Get uptime: `docker ps --filter name=<name> --format {{.Status}}`

**Auto-Config Update**:
- On start: Set `telemetry.enabled = true`
- On stop: Set `telemetry.enabled = false`
- Silent fail - not critical

### Coding Conventions

- **File Naming**: `aspire.ts` in `src/telemetry/`
- **Test Location**: `__tests__/aspire.test.ts` co-located with source
- **Imports**: Use `.js` extensions for ESM compatibility
- **No console.log**: Use callbacks for debug output
- **Type Safety**: Full TypeScript types for all public APIs

## Relevant Files

### Existing Files
- `src/telemetry/types.ts`: TelemetryErrorCode, TelemetryResponse - lines 17-47
- `src/telemetry/setup.ts`: isEndpointReachable() pattern - lines 59-87
- `src/telemetry/index.ts`: Public API exports
- `src/config/manager.ts`: ConfigManager class - lines 152-518
- `src/config/schema.ts`: TelemetryConfigSchema - lines 164-177
- `src/config/types.ts`: ConfigResponse type

### New Files
- `src/telemetry/aspire.ts`: Aspire Dashboard management functions
- `src/telemetry/__tests__/aspire.test.ts`: Unit tests
- `src/runtime/subprocess.ts`: Runtime boundary for Bun/Node subprocess abstraction
- `src/runtime/index.ts`: Public exports for runtime module

## Implementation Plan

### Phase 1: Define Types and Constants
Define Aspire-specific types and constants for container management.

### Phase 2: Implement Docker Helpers
Create helper functions for running Docker commands with timeout handling.

### Phase 3: Implement Dashboard Functions
Create the main functions for start/stop/status/url operations.

### Phase 4: Add Config Integration
Integrate with ConfigManager to auto-enable/disable telemetry.

### Phase 5: Tests and Validation
Create comprehensive unit tests with mocked subprocess execution.

## Step by Step Tasks

### Task 1: Add new error codes to TelemetryErrorCode

**Description**: Extend TelemetryErrorCode with Aspire-specific error codes.

**Files to modify**: `src/telemetry/types.ts`

**Implementation Details**:

Add the following error codes to the `TelemetryErrorCode` type:

```typescript
export type TelemetryErrorCode =
  | 'INITIALIZATION_FAILED'
  | 'ENDPOINT_UNREACHABLE'
  | 'EXPORT_FAILED'
  | 'INVALID_CONFIG'
  | 'ALREADY_INITIALIZED'
  | 'NOT_INITIALIZED'
  // New Aspire-specific codes
  | 'DOCKER_NOT_INSTALLED'
  | 'DOCKER_NOT_RUNNING'
  | 'CONTAINER_START_FAILED'
  | 'CONTAINER_STOP_FAILED'
  | 'TIMEOUT'
  | 'UNKNOWN';
```

---

### Task 2: Create Aspire Dashboard module

**Description**: Create the main module with types, constants, and Docker helper functions.

**Files to create**: `src/telemetry/aspire.ts`

**Implementation Details**:

```typescript
/**
 * Aspire Dashboard Docker container management.
 * Provides functions to start/stop/status the Aspire Dashboard for local observability.
 *
 * @see https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/dashboard/overview
 */

import type { TelemetryResponse, TelemetryErrorCode } from './types.js';
import { spawnProcess } from '../runtime/subprocess.js';

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

/** Docker container name for the Aspire Dashboard */
export const ASPIRE_CONTAINER_NAME = 'aspire-dashboard';

/** URL for accessing the Aspire Dashboard UI */
export const ASPIRE_DASHBOARD_URL = 'http://localhost:18888';

/** OTLP gRPC endpoint exposed by the Aspire Dashboard */
export const ASPIRE_OTLP_GRPC_ENDPOINT = 'http://localhost:4317';

/** OTLP HTTP endpoint (internal port 18889 mapped to 4317) */
export const ASPIRE_OTLP_HTTP_ENDPOINT = 'http://localhost:4318';

/** Docker image for the Aspire Dashboard */
export const ASPIRE_IMAGE = 'mcr.microsoft.com/dotnet/aspire-dashboard:latest';

/** Default timeout for Docker commands in milliseconds */
export const DOCKER_COMMAND_TIMEOUT_MS = 30000;

/** Short timeout for quick checks (version, info) */
export const DOCKER_CHECK_TIMEOUT_MS = 10000;

/** Startup wait time after container starts */
export const CONTAINER_STARTUP_WAIT_MS = 3000;

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

/**
 * Result of checking Aspire Dashboard status.
 */
export interface AspireStatus {
  /** Whether the container is currently running */
  running: boolean;
  /** Container uptime status (e.g., "Up 5 minutes") */
  uptime?: string;
  /** URL for the dashboard UI */
  dashboardUrl: string;
  /** OTLP gRPC endpoint for sending traces */
  otlpEndpoint: string;
}

/**
 * Options for Aspire operations.
 */
export interface AspireOptions {
  /** Callback for debug messages */
  onDebug?: (message: string) => void;
  /** Custom timeout for Docker commands */
  timeout?: number;
}

/**
 * Result of a Docker command execution.
 */
interface DockerCommandResult {
  exitCode: number;
  stdout: string;
  stderr: string;
}

// -----------------------------------------------------------------------------
// Response Helpers
// -----------------------------------------------------------------------------

function successResponse<T>(result: T, message: string): TelemetryResponse<T> {
  return { success: true, result, message };
}

function errorResponse(error: TelemetryErrorCode, message: string): TelemetryResponse<never> {
  return { success: false, error, message };
}

// -----------------------------------------------------------------------------
// Docker Command Helpers
// -----------------------------------------------------------------------------

/**
 * Run a Docker command with timeout handling.
 *
 * @param args - Docker command arguments (without 'docker' prefix)
 * @param timeoutMs - Command timeout in milliseconds
 * @returns Command result with exit code, stdout, and stderr
 */
async function runDockerCommand(
  args: string[],
  timeoutMs: number = DOCKER_COMMAND_TIMEOUT_MS
): Promise<DockerCommandResult> {
  try {
    // Use Promise.race for timeout handling
    const resultPromise = spawnProcess(['docker', ...args], {
      stdout: 'pipe',
      stderr: 'pipe',
    });

    const timeoutPromise = new Promise<DockerCommandResult>((_, reject) => {
      setTimeout(() => {
        reject(new Error('Command timed out'));
      }, timeoutMs);
    });

    return await Promise.race([resultPromise, timeoutPromise]);
  } catch (error) {
    // Handle spawn errors (Docker not installed)
    if (error instanceof Error && error.message.includes('ENOENT')) {
      return { exitCode: -1, stdout: '', stderr: 'Docker not found' };
    }

    if (error instanceof Error && error.message.includes('timed out')) {
      return { exitCode: -1, stdout: '', stderr: 'Command timed out' };
    }

    const message = error instanceof Error ? error.message : 'Unknown error';
    return { exitCode: -1, stdout: '', stderr: message };
  }
}

/**
 * Check if Docker CLI is installed and daemon is running.
 *
 * @param onDebug - Debug callback
 * @returns Error response if Docker is not available, undefined if OK
 */
async function checkDockerAvailability(
  onDebug?: (message: string) => void
): Promise<TelemetryResponse<never> | undefined> {
  const debug = onDebug ?? ((_msg: string): void => {});

  // Check Docker CLI
  debug('Checking Docker CLI availability...');
  const versionResult = await runDockerCommand(['--version'], DOCKER_CHECK_TIMEOUT_MS);

  if (versionResult.exitCode !== 0) {
    if (versionResult.stderr.includes('not found') || versionResult.stderr.includes('ENOENT')) {
      return errorResponse(
        'DOCKER_NOT_INSTALLED',
        'Docker is not installed. Install from: https://docs.docker.com/get-docker/'
      );
    }
    return errorResponse('DOCKER_NOT_INSTALLED', `Docker check failed: ${versionResult.stderr}`);
  }

  debug(`Docker CLI found: ${versionResult.stdout}`);

  // Check Docker daemon
  debug('Checking Docker daemon...');
  const infoResult = await runDockerCommand(['info'], DOCKER_CHECK_TIMEOUT_MS);

  if (infoResult.exitCode !== 0) {
    return errorResponse(
      'DOCKER_NOT_RUNNING',
      'Docker daemon is not running. Please start Docker Desktop or the Docker daemon.'
    );
  }

  debug('Docker daemon is running');
  return undefined;
}

/**
 * Check if the Aspire container is currently running.
 *
 * @param onDebug - Debug callback
 * @returns Status information if running, undefined if not
 */
async function checkContainerRunning(
  onDebug?: (message: string) => void
): Promise<{ running: boolean; uptime?: string }> {
  const debug = onDebug ?? ((_msg: string): void => {});

  debug('Checking if container is running...');
  const psResult = await runDockerCommand(
    ['ps', '--filter', `name=${ASPIRE_CONTAINER_NAME}`, '--format', '{{.Names}}'],
    DOCKER_CHECK_TIMEOUT_MS
  );

  if (psResult.stdout.includes(ASPIRE_CONTAINER_NAME)) {
    // Get uptime
    const uptimeResult = await runDockerCommand(
      ['ps', '--filter', `name=${ASPIRE_CONTAINER_NAME}`, '--format', '{{.Status}}'],
      DOCKER_CHECK_TIMEOUT_MS
    );

    debug(`Container is running: ${uptimeResult.stdout}`);
    return { running: true, uptime: uptimeResult.stdout || undefined };
  }

  debug('Container is not running');
  return { running: false };
}

// -----------------------------------------------------------------------------
// Public API
// -----------------------------------------------------------------------------

/**
 * Start the Aspire Dashboard Docker container.
 *
 * This function:
 * 1. Checks if Docker is installed and running
 * 2. Checks if the container is already running
 * 3. Starts the container if not running
 * 4. Waits for startup
 *
 * @param options - Aspire operation options
 * @returns Status of the dashboard after starting
 *
 * @example
 * ```typescript
 * const result = await startAspireDashboard();
 * if (result.success) {
 *   console.log(`Dashboard: ${result.result.dashboardUrl}`);
 * }
 * ```
 */
export async function startAspireDashboard(
  options: AspireOptions = {}
): Promise<TelemetryResponse<AspireStatus>> {
  const debug = options.onDebug ?? ((_msg: string): void => {});

  // Check Docker availability
  const dockerError = await checkDockerAvailability(debug);
  if (dockerError) {
    return dockerError;
  }

  // Check if already running
  const status = await checkContainerRunning(debug);
  if (status.running) {
    return successResponse(
      {
        running: true,
        uptime: status.uptime,
        dashboardUrl: ASPIRE_DASHBOARD_URL,
        otlpEndpoint: ASPIRE_OTLP_GRPC_ENDPOINT,
      },
      'Dashboard is already running'
    );
  }

  // Start container
  debug('Starting Aspire Dashboard container...');
  const timeout = options.timeout ?? DOCKER_COMMAND_TIMEOUT_MS;

  const startResult = await runDockerCommand(
    [
      'run',
      '--rm',
      '-d',
      '-p',
      '18888:18888',
      '-p',
      '4317:18889',
      '--name',
      ASPIRE_CONTAINER_NAME,
      '-e',
      'DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS=true',
      ASPIRE_IMAGE,
    ],
    timeout
  );

  if (startResult.exitCode !== 0) {
    // Check for common errors
    if (startResult.stderr.includes('port is already allocated')) {
      return errorResponse(
        'CONTAINER_START_FAILED',
        'Port 18888 or 4317 is already in use. Stop the conflicting service or use different ports.'
      );
    }
    if (startResult.stderr.includes('Conflict')) {
      return errorResponse(
        'CONTAINER_START_FAILED',
        `Container "${ASPIRE_CONTAINER_NAME}" already exists. Run: docker rm ${ASPIRE_CONTAINER_NAME}`
      );
    }
    return errorResponse('CONTAINER_START_FAILED', `Failed to start container: ${startResult.stderr}`);
  }

  // Wait for startup
  debug(`Container started. Waiting ${CONTAINER_STARTUP_WAIT_MS}ms for initialization...`);
  await new Promise((resolve) => setTimeout(resolve, CONTAINER_STARTUP_WAIT_MS));

  // Verify it's running
  const verifyStatus = await checkContainerRunning(debug);
  if (!verifyStatus.running) {
    return errorResponse(
      'CONTAINER_START_FAILED',
      'Container started but is no longer running. Check Docker logs for errors.'
    );
  }

  debug('Dashboard started successfully');
  return successResponse(
    {
      running: true,
      uptime: verifyStatus.uptime,
      dashboardUrl: ASPIRE_DASHBOARD_URL,
      otlpEndpoint: ASPIRE_OTLP_GRPC_ENDPOINT,
    },
    'Dashboard started successfully'
  );
}

/**
 * Stop the Aspire Dashboard Docker container.
 *
 * @param options - Aspire operation options
 * @returns Success/failure status
 *
 * @example
 * ```typescript
 * const result = await stopAspireDashboard();
 * if (result.success) {
 *   console.log('Dashboard stopped');
 * }
 * ```
 */
export async function stopAspireDashboard(
  options: AspireOptions = {}
): Promise<TelemetryResponse> {
  const debug = options.onDebug ?? ((_msg: string): void => {});

  // Check Docker availability
  const dockerError = await checkDockerAvailability(debug);
  if (dockerError) {
    return dockerError;
  }

  // Check if running
  const status = await checkContainerRunning(debug);
  if (!status.running) {
    return successResponse(undefined, 'Dashboard was not running');
  }

  // Stop container
  debug('Stopping Aspire Dashboard container...');
  const timeout = options.timeout ?? DOCKER_COMMAND_TIMEOUT_MS;

  const stopResult = await runDockerCommand(['stop', ASPIRE_CONTAINER_NAME], timeout);

  if (stopResult.exitCode !== 0) {
    return errorResponse('CONTAINER_STOP_FAILED', `Failed to stop container: ${stopResult.stderr}`);
  }

  debug('Dashboard stopped successfully');
  return successResponse(undefined, 'Dashboard stopped');
}

/**
 * Get the current status of the Aspire Dashboard.
 *
 * @param options - Aspire operation options
 * @returns Current dashboard status
 *
 * @example
 * ```typescript
 * const result = await getAspireStatus();
 * if (result.success && result.result.running) {
 *   console.log(`Uptime: ${result.result.uptime}`);
 * }
 * ```
 */
export async function getAspireStatus(
  options: AspireOptions = {}
): Promise<TelemetryResponse<AspireStatus>> {
  const debug = options.onDebug ?? ((_msg: string): void => {});

  // Check Docker availability
  const dockerError = await checkDockerAvailability(debug);
  if (dockerError) {
    return dockerError;
  }

  // Check container status
  const status = await checkContainerRunning(debug);

  return successResponse(
    {
      running: status.running,
      uptime: status.uptime,
      dashboardUrl: ASPIRE_DASHBOARD_URL,
      otlpEndpoint: ASPIRE_OTLP_GRPC_ENDPOINT,
    },
    status.running ? 'Dashboard is running' : 'Dashboard is not running'
  );
}

/**
 * Get the Aspire Dashboard URL and current telemetry configuration status.
 *
 * @param envEnabled - Whether telemetry is enabled via environment variable
 * @returns URL information and telemetry status
 *
 * @example
 * ```typescript
 * const info = getAspireUrl(process.env.ENABLE_OTEL === 'true');
 * console.log(`Dashboard: ${info.dashboardUrl}`);
 * ```
 */
export function getAspireUrl(envEnabled?: boolean): {
  dashboardUrl: string;
  otlpEndpoint: string;
  telemetryStatus: 'enabled' | 'disabled' | 'auto';
} {
  let telemetryStatus: 'enabled' | 'disabled' | 'auto' = 'auto';

  if (envEnabled !== undefined) {
    telemetryStatus = envEnabled ? 'enabled' : 'disabled';
  }

  return {
    dashboardUrl: ASPIRE_DASHBOARD_URL,
    otlpEndpoint: ASPIRE_OTLP_GRPC_ENDPOINT,
    telemetryStatus,
  };
}
```

---

### Task 3: Create config integration helpers

**Description**: Add helper functions to update telemetry config when starting/stopping the dashboard.

**Files to modify**: `src/telemetry/aspire.ts`

**Implementation Details**:

Add the following to the end of `aspire.ts`:

```typescript
// -----------------------------------------------------------------------------
// Config Integration
// -----------------------------------------------------------------------------

import { ConfigManager } from '../config/manager.js';
import type { AppConfig } from '../config/schema.js';

/**
 * Options for config-aware Aspire operations.
 */
export interface AspireConfigOptions extends AspireOptions {
  /** Config manager instance (creates new one if not provided) */
  configManager?: ConfigManager;
  /** Whether to auto-update telemetry config */
  autoUpdateConfig?: boolean;
}

/**
 * Update telemetry.enabled in config.
 * Silently fails if config operations fail (not critical).
 *
 * @param enabled - Whether to enable telemetry
 * @param manager - Config manager instance
 * @param onDebug - Debug callback
 */
async function updateTelemetryConfig(
  enabled: boolean,
  manager: ConfigManager,
  onDebug?: (message: string) => void
): Promise<void> {
  const debug = onDebug ?? ((_msg: string): void => {});

  try {
    debug(`Updating telemetry config: enabled=${enabled}`);
    const loadResult = await manager.load();

    if (!loadResult.success) {
      debug(`Failed to load config: ${loadResult.message}`);
      return;
    }

    const config = loadResult.result;
    config.telemetry.enabled = enabled;

    const saveResult = await manager.save(config);
    if (!saveResult.success) {
      debug(`Failed to save config: ${saveResult.message}`);
      return;
    }

    debug('Telemetry config updated successfully');
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    debug(`Config update failed: ${message}`);
    // Silent fail - not critical
  }
}

/**
 * Start the Aspire Dashboard with automatic config update.
 *
 * @param options - Operation options including config integration
 * @returns Status of the dashboard after starting
 *
 * @example
 * ```typescript
 * const result = await startAspireDashboardWithConfig({
 *   autoUpdateConfig: true,
 * });
 * ```
 */
export async function startAspireDashboardWithConfig(
  options: AspireConfigOptions = {}
): Promise<TelemetryResponse<AspireStatus>> {
  const result = await startAspireDashboard(options);

  // Auto-enable telemetry in config on successful start
  if (result.success && options.autoUpdateConfig !== false) {
    const manager = options.configManager ?? new ConfigManager();
    await updateTelemetryConfig(true, manager, options.onDebug);
  }

  return result;
}

/**
 * Stop the Aspire Dashboard with automatic config update.
 *
 * @param options - Operation options including config integration
 * @returns Success/failure status
 *
 * @example
 * ```typescript
 * const result = await stopAspireDashboardWithConfig({
 *   autoUpdateConfig: true,
 * });
 * ```
 */
export async function stopAspireDashboardWithConfig(
  options: AspireConfigOptions = {}
): Promise<TelemetryResponse> {
  const result = await stopAspireDashboard(options);

  // Auto-disable telemetry in config on successful stop
  if (result.success && options.autoUpdateConfig !== false) {
    const manager = options.configManager ?? new ConfigManager();
    await updateTelemetryConfig(false, manager, options.onDebug);
  }

  return result;
}
```

---

### Task 4: Update telemetry index exports

**Description**: Export new Aspire functions from the telemetry module.

**Files to modify**: `src/telemetry/index.ts`

**Implementation Details**:

Add the following exports to the end of the file:

```typescript
// ─── Aspire Dashboard Management ─────────────────────────────────────────────
export {
  // Constants
  ASPIRE_CONTAINER_NAME,
  ASPIRE_DASHBOARD_URL,
  ASPIRE_OTLP_GRPC_ENDPOINT,
  ASPIRE_OTLP_HTTP_ENDPOINT,
  ASPIRE_IMAGE,
  // Core functions
  startAspireDashboard,
  stopAspireDashboard,
  getAspireStatus,
  getAspireUrl,
  // Config-integrated functions
  startAspireDashboardWithConfig,
  stopAspireDashboardWithConfig,
} from './aspire.js';

export type { AspireStatus, AspireOptions, AspireConfigOptions } from './aspire.js';
```

---

### Task 5: Create unit tests

**Description**: Write comprehensive unit tests for the Aspire Dashboard functions.

**Files to create**: `src/telemetry/__tests__/aspire.test.ts`

**Implementation Details**:

```typescript
/**
 * Tests for Aspire Dashboard management functions.
 *
 * NOTE: Uses Jest with ESM module mocking. The runtime/subprocess module
 * provides the abstraction layer that enables clean testing without
 * shimming Bun globals.
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import type { SubprocessResult } from '../../runtime/subprocess.js';

// Mock the subprocess module (runtime boundary pattern)
jest.unstable_mockModule('../../runtime/subprocess.js', () => ({
  spawnProcess: jest.fn(),
  isBunRuntime: jest.fn(() => false),
}));

// Helper to create mock subprocess results
function mockResult(stdout: string, stderr: string, exitCode: number): SubprocessResult {
  return { exitCode, stdout, stderr };
}

describe('Aspire Dashboard Management', () => {
  let spawnProcess: jest.Mock;

  beforeEach(async () => {
    jest.clearAllMocks();
    // Get the mocked function
    const subprocess = await import('../../runtime/subprocess.js');
    spawnProcess = subprocess.spawnProcess as jest.Mock;
  });

  afterEach(() => {
    jest.resetModules();
  });

  describe('startAspireDashboard', () => {
    it('returns error when Docker is not installed', async () => {
      spawnProcess.mockResolvedValue(mockResult('', 'Docker not found', -1));

      const { startAspireDashboard } = await import('../aspire.js');
      const result = await startAspireDashboard();

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBe('DOCKER_NOT_INSTALLED');
      }
    });

    it('returns error when Docker daemon is not running', async () => {
      spawnProcess
        .mockResolvedValueOnce(mockResult('Docker version 24.0.0', '', 0))
        .mockResolvedValueOnce(mockResult('', 'Cannot connect to the Docker daemon', 1));

      const { startAspireDashboard } = await import('../aspire.js');
      const result = await startAspireDashboard();

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBe('DOCKER_NOT_RUNNING');
      }
    });

    it('returns success when container is already running', async () => {
      spawnProcess
        .mockResolvedValueOnce(mockResult('Docker version 24.0.0', '', 0)) // --version
        .mockResolvedValueOnce(mockResult('Server Version: 24.0.0', '', 0)) // info
        .mockResolvedValueOnce(mockResult('aspire-dashboard', '', 0)) // ps (names)
        .mockResolvedValueOnce(mockResult('Up 5 minutes', '', 0)); // ps (status)

      const { startAspireDashboard } = await import('../aspire.js');
      const result = await startAspireDashboard();

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.result.running).toBe(true);
        expect(result.message).toContain('already running');
      }
    });

    it('starts container when not running', async () => {
      spawnProcess
        .mockResolvedValueOnce(mockResult('Docker version 24.0.0', '', 0)) // --version
        .mockResolvedValueOnce(mockResult('Server Version: 24.0.0', '', 0)) // info
        .mockResolvedValueOnce(mockResult('', '', 0)) // ps (not running)
        .mockResolvedValueOnce(mockResult('container_id_123', '', 0)) // run
        .mockResolvedValueOnce(mockResult('aspire-dashboard', '', 0)) // ps verify (names)
        .mockResolvedValueOnce(mockResult('Up 1 second', '', 0)); // ps verify (status)

      const { startAspireDashboard, CONTAINER_STARTUP_WAIT_MS } = await import('../aspire.js');

      // Use fake timers to speed up test
      jest.useFakeTimers();
      const resultPromise = startAspireDashboard();
      await jest.advanceTimersByTimeAsync(CONTAINER_STARTUP_WAIT_MS + 1000);
      const result = await resultPromise;
      jest.useRealTimers();

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.result.running).toBe(true);
        expect(result.message).toContain('started successfully');
      }
    });
  });

  describe('stopAspireDashboard', () => {
    it('returns success when container is not running', async () => {
      spawnProcess
        .mockResolvedValueOnce(mockResult('Docker version 24.0.0', '', 0))
        .mockResolvedValueOnce(mockResult('Server Version: 24.0.0', '', 0))
        .mockResolvedValueOnce(mockResult('', '', 0)); // ps (not running)

      const { stopAspireDashboard } = await import('../aspire.js');
      const result = await stopAspireDashboard();

      expect(result.success).toBe(true);
      expect(result.message).toContain('was not running');
    });

    it('stops running container', async () => {
      spawnProcess
        .mockResolvedValueOnce(mockResult('Docker version 24.0.0', '', 0))
        .mockResolvedValueOnce(mockResult('Server Version: 24.0.0', '', 0))
        .mockResolvedValueOnce(mockResult('aspire-dashboard', '', 0)) // ps (names)
        .mockResolvedValueOnce(mockResult('Up 5 minutes', '', 0)) // ps (status)
        .mockResolvedValueOnce(mockResult('aspire-dashboard', '', 0)); // stop

      const { stopAspireDashboard } = await import('../aspire.js');
      const result = await stopAspireDashboard();

      expect(result.success).toBe(true);
      expect(result.message).toContain('stopped');
    });
  });

  describe('getAspireStatus', () => {
    it('returns not running status', async () => {
      spawnProcess
        .mockResolvedValueOnce(mockResult('Docker version 24.0.0', '', 0))
        .mockResolvedValueOnce(mockResult('Server Version: 24.0.0', '', 0))
        .mockResolvedValueOnce(mockResult('', '', 0)); // ps (not running)

      const { getAspireStatus } = await import('../aspire.js');
      const result = await getAspireStatus();

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.result.running).toBe(false);
        expect(result.result.dashboardUrl).toBe('http://localhost:18888');
      }
    });

    it('returns running status with uptime', async () => {
      spawnProcess
        .mockResolvedValueOnce(mockResult('Docker version 24.0.0', '', 0))
        .mockResolvedValueOnce(mockResult('Server Version: 24.0.0', '', 0))
        .mockResolvedValueOnce(mockResult('aspire-dashboard', '', 0)) // ps (names)
        .mockResolvedValueOnce(mockResult('Up 10 minutes', '', 0)); // ps (status)

      const { getAspireStatus } = await import('../aspire.js');
      const result = await getAspireStatus();

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.result.running).toBe(true);
        expect(result.result.uptime).toBe('Up 10 minutes');
      }
    });
  });

  describe('getAspireUrl', () => {
    it('returns URLs with auto status when no argument provided', async () => {
      const { getAspireUrl } = await import('../aspire.js');
      const result = getAspireUrl();

      expect(result.dashboardUrl).toBe('http://localhost:18888');
      expect(result.otlpEndpoint).toBe('http://localhost:4317');
      expect(result.telemetryStatus).toBe('auto');
    });

    it('returns URLs with enabled status', async () => {
      const { getAspireUrl } = await import('../aspire.js');
      const result = getAspireUrl(true);
      expect(result.telemetryStatus).toBe('enabled');
    });

    it('returns URLs with disabled status', async () => {
      const { getAspireUrl } = await import('../aspire.js');
      const result = getAspireUrl(false);
      expect(result.telemetryStatus).toBe('disabled');
    });
  });

  describe('Constants', () => {
    it('exports correct constants', async () => {
      const {
        ASPIRE_CONTAINER_NAME,
        ASPIRE_DASHBOARD_URL,
        ASPIRE_OTLP_GRPC_ENDPOINT,
        ASPIRE_IMAGE,
      } = await import('../aspire.js');

      expect(ASPIRE_CONTAINER_NAME).toBe('aspire-dashboard');
      expect(ASPIRE_DASHBOARD_URL).toBe('http://localhost:18888');
      expect(ASPIRE_OTLP_GRPC_ENDPOINT).toBe('http://localhost:4317');
      expect(ASPIRE_IMAGE).toBe('mcr.microsoft.com/dotnet/aspire-dashboard:latest');
    });
  });
});
```

---

### Task 6: Run validation

**Description**: Run all quality checks to ensure implementation is correct.

**Commands**:
```bash
# Run all validation commands
bun run typecheck && bun run lint && bun run test && bun run build

# Run just the telemetry tests
bun run test src/telemetry/__tests__/aspire.test.ts

# Run with coverage
bun run test:coverage src/telemetry
```

---

## Testing Strategy

### Unit Tests

Tests for `src/telemetry/__tests__/aspire.test.ts`:

**Docker Availability**:
- Returns error when Docker CLI not installed
- Returns error when Docker daemon not running
- Handles timeout scenarios

**startAspireDashboard**:
- Returns success when container already running
- Starts container when not running
- Returns error on port conflict
- Returns error on container name conflict

**stopAspireDashboard**:
- Returns success when container not running
- Stops running container
- Returns error on stop failure

**getAspireStatus**:
- Returns not running status
- Returns running status with uptime
- Returns correct URLs

**getAspireUrl**:
- Returns correct URLs
- Returns correct telemetry status for enabled/disabled/auto

**Config Integration**:
- startAspireDashboardWithConfig enables telemetry
- stopAspireDashboardWithConfig disables telemetry
- Config update fails silently

### Integration Tests
- Full start/stop cycle with real Docker (manual testing)
- Config persistence verification

### Edge Cases
- Docker command timeout
- Container crashes after start
- Port already in use
- Container name already exists
- Config file doesn't exist
- Config file permissions issues

## Acceptance Criteria

- [x] `startAspireDashboard()` starts the Aspire Dashboard container
- [x] `stopAspireDashboard()` stops the running container
- [x] `getAspireStatus()` returns accurate container status with uptime
- [x] `getAspireUrl()` returns dashboard URL and telemetry status
- [x] Returns `DOCKER_NOT_INSTALLED` error when Docker is not available
- [x] Returns `DOCKER_NOT_RUNNING` error when Docker daemon is not running
- [x] Returns `CONTAINER_START_FAILED` with clear message for port conflicts
- [x] `startAspireDashboardWithConfig()` auto-enables telemetry in config
- [x] `stopAspireDashboardWithConfig()` auto-disables telemetry in config
- [x] Config update failures are silent (not critical)
- [x] All exports available from `src/telemetry/index.ts`
- [x] Unit tests achieve 85%+ coverage
- [x] All quality gates pass (typecheck, lint, test, build)

## Validation Commands

```bash
# Run all validation commands before committing
bun run typecheck && bun run lint && bun run test && bun run build

# Run just the Aspire tests
bun run test src/telemetry/__tests__/aspire.test.ts

# Verify exports work
bun -e "import { startAspireDashboard, ASPIRE_DASHBOARD_URL } from './src/telemetry/index.js'; console.log('Exports OK')"

# Manual integration test (requires Docker)
bun -e "
import { startAspireDashboard, getAspireStatus, stopAspireDashboard } from './src/telemetry/index.js';

async function test() {
  console.log('Starting dashboard...');
  const start = await startAspireDashboard({ onDebug: console.log });
  console.log('Start result:', start);

  console.log('\\nGetting status...');
  const status = await getAspireStatus();
  console.log('Status:', status);

  console.log('\\nStopping dashboard...');
  const stop = await stopAspireDashboard();
  console.log('Stop result:', stop);
}

test().catch(console.error);
"
```

## Notes

### Aspire Dashboard

The .NET Aspire Dashboard is a lightweight observability dashboard that accepts OpenTelemetry data and provides visualization for:
- Distributed traces
- Structured logs
- Metrics

It's the recommended local observability solution for .NET Aspire applications but works with any OpenTelemetry-compliant data source.

### Port Mapping

The container exposes:
- **18888:18888** - Dashboard UI (HTTP)
- **4317:18889** - OTLP gRPC endpoint (internal 18889 mapped to standard 4317)

The OTLP HTTP endpoint (4318) is not exposed by default. If needed, add `-p 4318:18890` to the run command.

### Config Update Behavior

The auto-config update is designed to be non-critical:
- On start: Enables `telemetry.enabled` so traces are sent
- On stop: Disables `telemetry.enabled` to avoid connection errors
- Failures are logged but don't affect the operation result

This matches the Python implementation behavior.

### Testing Strategy

The implementation uses a **runtime boundary pattern** for testability:
- `src/runtime/subprocess.ts` abstracts `Bun.spawn` vs Node `child_process.spawn`
- Tests mock the subprocess module using Jest's `jest.unstable_mockModule()`
- This avoids shimming Bun globals and keeps tests clean
- The pattern scales for future Bun-specific APIs

Key testing techniques:
- Sequential mock responses with `mockResolvedValueOnce()` for Docker command sequences
- Jest fake timers with `jest.advanceTimersByTimeAsync()` for startup delay tests
- Module reset with `jest.resetModules()` to ensure fresh imports per test

### Future Enhancements

Potential post-MVP improvements:
1. Custom port mapping options
2. Volume mounting for persistent data
3. Health check endpoint polling instead of sleep
4. Support for other dashboards (Jaeger, Zipkin)

## Execution

This spec can be implemented using: `/sdlc:implement docs/specs/feature-011-aspire-dashboard-integration.md`
